/**
 * MCP Client Utility Functions
 * Common workflow helpers and combinators
 */

import type {
  Result,
  WebSearchOptions,
  ReadUrlOptions,
} from './types.js';
import {
  WebSearchClient,
  WebReaderClient,
} from './index.js';

// ============================================================================
// Research Workflow Helpers
// ============================================================================

/**
 * Research workflow: Search → Read → Summarize
 *
 * @param query - Research query
 * @param options - Workflow options
 * @returns Promise<string> - Research summary
 *
 * @example
 * ```typescript
 * const summary = await researchWorkflow('Browser MCP servers', {
 *   maxResults: 5,
 *   timeRange: 'oneWeek'
 * });
 * ```
 */
export async function researchWorkflow(
  query: string,
  options?: {
    maxResults?: number;
    timeRange?: WebSearchOptions['timeRange'];
    location?: WebSearchOptions['location'];
    summarize?: boolean;
  }
): Promise<Result<string>> {
  try {
    // Step 1: Search web
    const searchClient = new WebSearchClient();
    const searchResult = await searchClient.search({
      query,
      timeRange: options?.timeRange,
      location: options?.location,
    });

    if (!searchResult.success) {
      return searchResult as Result<string>;
    }

    const searchResults = searchResult.data.slice(0, options?.maxResults || 5);

    // Step 2: Read top results
    const readerClient = new WebReaderClient();
    const urls = searchResults.map(r => r.url);

    const readResult = await readerClient.readMultiple(
      urls,
      {
        retainImages: false,
        returnFormat: 'markdown',
      }
    );

    if (!readResult.success) {
      return readResult as Result<string>;
    }

    // Step 3: Summarize findings
    const contents = Array.from(readResult.data.values());
    const summary = summarizeResearch(query, searchResults, contents);

    return { success: true, data: summary };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error : new Error(String(error)),
    };
  }
}

/**
 * Summarize research findings
 */
function summarizeResearch(
  query: string,
  searchResults: Array<{ title: string; url: string; summary: string }>,
  contents: string[]
): string {
  const lines = [
    `# Research Summary: ${query}`,
    '',
    `## Sources (${searchResults.length})`,
    '',
    ...searchResults.map((result, i) => {
      return `${i + 1}. **${result.title}**\n   ${result.url}\n   ${result.summary}`;
    }),
    '',
    '## Key Findings',
    '',
    ...contents.slice(0, 3).map((content, i) => {
      const preview = content.substring(0, 500);
      return `### Source ${i + 1}\n\n${preview}${content.length > 500 ? '...' : ''}\n`;
    }),
    '',
    '---',
    '*Generated by browser-automation MCP client*',
  ];

  return lines.join('\n');
}

// ============================================================================
// Competitor Analysis Workflow
// ============================================================================

/**
 * Competitor analysis workflow
 *
 * @param query - Search query
 * @param competitorDomains - Array of competitor domains
 * @returns Promise<string> - Competitor analysis
 *
 * @example
 * ```typescript
 * const analysis = await competitorAnalysis(
 *   'project management tools',
 *   ['asana.com', 'trello.com', 'monday.com']
 * );
 * ```
 */
export async function competitorAnalysis(
  query: string,
  competitorDomains: string[]
): Promise<Result<string>> {
  try {
    // Search for competitors
    const searchClient = new WebSearchClient();
    const searchResults: Array<{ title: string; url: string; summary: string; domain: string }> = [];

    for (const domain of competitorDomains) {
      const result = await searchClient.searchDomains(
        `site:${domain} ${query}`,
        [domain]
      );

      if (result.success) {
        const enriched = result.data.map(r => ({
          ...r,
          domain,
        }));
        searchResults.push(...enriched);
      }
    }

    if (searchResults.length === 0) {
      return {
        success: true,
        data: `No competitor information found for: ${competitorDomains.join(', ')}`,
      };
    }

    // Format analysis
    const analysis = formatCompetitorAnalysis(query, competitorDomains, searchResults);

    return { success: true, data: analysis };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error : new Error(String(error)),
    };
  }
}

/**
 * Format competitor analysis results
 */
function formatCompetitorAnalysis(
  query: string,
  domains: string[],
  results: Array<{ domain: string; title: string; url: string; summary: string }>
): string {
  const byDomain = domains.map(domain => {
    const domainResults = results.filter(r => r.domain === domain);
    return {
      domain,
      results: domainResults,
    };
  });

  const lines = [
    `# Competitor Analysis: ${query}`,
    '',
    `## Analyzed Competitors`,
    '',
    ...byDomain.map(({ domain, results: domainResults }) => {
      return [
        `### ${domain}`,
        '',
        `Found ${domainResults.length} result(s)`,
        '',
        ...domainResults.map(r => {
          return `- **${r.title}**\n  ${r.summary}`;
        }),
        '',
      ].join('\n');
    }),
    '---',
    '*Generated by browser-automation MCP client*',
  ];

  return lines.join('\n');
}

// ============================================================================
// URL Batch Processing Utilities
// ============================================================================

/**
 * Process multiple URLs with error handling
 *
 * @param urls - Array of URLs to process
 * @param processor - Function to process each URL content
 * @returns Promise<Map<string, Result<string>>> - Map of URL to processing result
 *
 * @example
 * ```typescript
 * const results = await processUrls(
 *   ['https://example.com', 'https://example.org'],
 *   async (url, content) => {
 *     // Process content
 *     return content.toUpperCase();
 *   }
 * );
 * ```
 */
export async function processUrls<T>(
  urls: string[],
  processor: (url: string, content: string) => Promise<T>
): Promise<Map<string, Result<T>>> {
  const results = new Map<string, Result<T>>();
  const readerClient = new WebReaderClient();

  // Read all URLs
  const readResult = await readerClient.readMultiple(urls);

  if (!readResult.success) {
    // All failed
    urls.forEach(url => {
      results.set(url, {
        success: false,
        error: readResult.error,
      });
    });
    return results;
  }

  // Process each URL
  for (const [url, content] of readResult.data.entries()) {
    try {
      const processed = await processor(url, content);
      results.set(url, { success: true, data: processed });
    } catch (error) {
      results.set(url, {
        success: false,
        error: error instanceof Error ? error : new Error(String(error)),
      });
    }
  }

  return results;
}

/**
 * Extract links from multiple URLs
 *
 * @param urls - Array of URLs to extract links from
 * @returns Promise<Map<string, string[]>> - Map of URL to extracted links
 *
 * @example
 * ```typescript
 * const links = await extractLinksFromUrls([
 *   'https://example.com',
 *   'https://example.org'
 * ]);
 * ```
 */
export async function extractLinksFromUrls(
  urls: string[]
): Promise<Result<Map<string, string[]>>> {
  const readerClient = new WebReaderClient();
  const linksMap = new Map<string, string[]>();

  try {
    for (const url of urls) {
      const result = await readerClient.readUrl({
        url,
        withLinksSummary: true,
      });

      if (result.success) {
        // Extract links from markdown content
        const linkRegex = /\[.*?\]\((.*?)\)/g;
        const links: string[] = [];
        let match;

        while ((match = linkRegex.exec(result.data)) !== null) {
          if (match[1] && !match[1].startsWith('data:')) {
            links.push(match[1]);
          }
        }

        linksMap.set(url, links);
      }
    }

    return { success: true, data: linksMap };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error : new Error(String(error)),
    };
  }
}

// ============================================================================
// Search Aggregation Utilities
// ============================================================================

/**
 * Aggregate multiple searches
 *
 * @param queries - Array of search queries
 * @returns Promise<Map<string, Result<string>>> - Map of query to search results
 *
 * @example
 * ```typescript
 * const results = await aggregateSearches([
 *   'Browser automation tools',
 *   'Web scraping comparison',
 *   'MCP servers'
 * ]);
 * ```
 */
export async function aggregateSearches(
  queries: string[],
  options?: Partial<WebSearchOptions>
): Promise<Map<string, Result<string>>> {
  const results = new Map<string, Result<string>>();
  const searchClient = new WebSearchClient();

  // Execute searches in parallel
  const searchPromises = queries.map(async (query) => {
    const result = await searchClient.searchWithSummary(query, options);
    return { query, result };
  });

  const searchResults = await Promise.all(searchPromises);

  for (const { query, result } of searchResults) {
    results.set(query, result);
  }

  return results;
}

/**
 * Search and read top N results
 *
 * @param query - Search query
 * @param readCount - Number of top results to read (default: 3)
 * @returns Promise<string> - Aggregated content
 *
 * @example
 * ```typescript
 * const content = await searchAndRead('Browser MCP', 5);
 * ```
 */
export async function searchAndRead(
  query: string,
  readCount: number = 3
): Promise<Result<string>> {
  try {
    const searchClient = new WebSearchClient();
    const readerClient = new WebReaderClient();

    // Search
    const searchResult = await searchClient.search({ query });

    if (!searchResult.success) {
      return searchResult as Result<string>;
    }

    // Get top URLs
    const topUrls = searchResult.data.slice(0, readCount).map(r => r.url);

    // Read them
    const readResult = await readerClient.readMultiple(topUrls);

    if (!readResult.success) {
      return readResult as Result<string>;
    }

    // Aggregate content
    const aggregated = Array.from(readResult.data.entries())
      .map(([url, content]) => {
        return `## ${url}\n\n${content}\n\n`;
      })
      .join('---\n\n');

    return { success: true, data: aggregated };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error : new Error(String(error)),
    };
  }
}

// ============================================================================
// Error Handling Utilities
// ============================================================================

/**
 * Safe execute with fallback
 *
 * @param fn - Function to execute
 * @param fallback - Fallback value if function fails
 * @returns Promise<T> - Result or fallback
 *
 * @example
 * ```typescript
 * const result = await safeExecute(
 *   () => webSearch('test'),
 *   []
 * );
 * ```
 */
export async function safeExecute<T>(
  fn: () => Promise<Result<T>>,
  fallback: T
): Promise<T> {
  try {
    const result = await fn();
    return result.success ? result.data : fallback;
  } catch {
    return fallback;
  }
}

/**
 * Execute with timeout
 *
 * @param fn - Function to execute
 * @param timeoutMs - Timeout in milliseconds
 * @returns Promise<Result<T>> - Result or timeout error
 *
 * @example
 * ```typescript
 * const result = await withTimeout(
 *   () => webSearch('test'),
 *   5000
 * );
 * ```
 */
export async function withTimeout<T>(
  fn: () => Promise<Result<T>>,
  timeoutMs: number
): Promise<Result<T>> {
  return Promise.race([
    fn(),
    new Promise<Result<T>>((resolve) =>
      setTimeout(
        () =>
          resolve({
            success: false,
            error: new Error(`Operation timed out after ${timeoutMs}ms`),
          }),
        timeoutMs
      )
    ),
  ]);
}
